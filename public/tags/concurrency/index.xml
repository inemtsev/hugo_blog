<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>concurrency on EventsLooped</title><link>https://www.eventslooped.com/tags/concurrency/</link><description>Recent content in concurrency on EventsLooped</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&amp;copy; Ilya Nemtsev 2019</copyright><lastBuildDate>Mon, 03 Jun 2019 21:16:17 +0700</lastBuildDate><atom:link href="https://www.eventslooped.com/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>Make Multiple Api Calls At The Same Time With GoRoutines</title><link>https://www.eventslooped.com/posts/golang-make-multiple-api-calls/</link><pubDate>Mon, 03 Jun 2019 21:16:17 +0700</pubDate><guid>https://www.eventslooped.com/posts/golang-make-multiple-api-calls/</guid><description>Golang is efficient, very efficient. Much of this efficiency is attributed to its unique abstractions when dealing with concurrency. Java for example, maps its threads to OS threads, while Go uses its own goroutines scheduler to further abstract its lightweight goroutines from OS threads. In short, Golang is very frugal with how it uses OS threads; if a goroutine becomes blocked, Go&amp;rsquo;s scheduler will switch in another goroutine in its place to keep the thread busy as much as possible.</description></item></channel></rss>